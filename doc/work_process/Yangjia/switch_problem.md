# switch出现的奇怪问题

## 问题描述

在移植 `printf` 的时候，发现有如下现象

1. `uart_puts` 函数可以正常输出字符串
2. `printf` 函数在没有格式串的情况下可以正常输出字符串
3. `printf` 函数在有格式串的情况下，会**反复输出**从 `start_kernel` 函数开始到格式串前面的所有的字符串

## 问题分析

参照 `0dd6a771d90ce1b81e9420881ff48a514cb6a646` 版本的设计和debug思想，发现问题出现在switch的跳跃。

当switch的**分支**超过5个，在loongarch的编译器中使用 `jirl` 语句实现, 会出现问题。

问题是：`jirl` 语句的跳转出错了。本来应该是根据编译时的分支所在的哈希表的位置，跳转到对应的分支，但是实际上跳转到了错误的位置。目前看来是跳转到了 `start_kernel` 函数的位置，导致 1) start_kernel 之前的代码被反复执行，2) 察觉到 `%` 格式匹配的前缀后，格式匹配不能够被正确执行，之后的代码也没有被执行。

result1.txt:
```asm
			switch (*s) {
80000658:	28bed2cc 	ld.w	$r12,$r22,-76(0xfb4)
8000065c:	2800018c 	ld.b	$r12,$r12,0
80000660:	02be758c 	addi.w	$r12,$r12,-99(0xf9d)
80000664:	0280540d 	addi.w	$r13,$r0,21(0x15)
80000668:	6803a9ac 	bltu	$r13,$r12,936(0x3a8) # 80000a10 <_vsnprintf+0x3fc>
8000066c:	0040898d 	slli.w	$r13,$r12,0x2
80000670:	1c00000c 	pcaddu12i	$r12,0
80000674:	029ae18c 	addi.w	$r12,$r12,1720(0x6b8)
80000678:	001031ac 	add.w	$r12,$r13,$r12
8000067c:	2880018c 	ld.w	$r12,$r12,0
80000680:	4c000180 	jirl	$r0,$r12,0
```

result.txt:
```
Contents of section .rodata:
 80000ca8 00000000 00000000 00000000 00000000  ................
 80000cb8 00000000 00000000 62626262 25636262  ........bbbb%cbb
 80000cc8 6262620a 00000000 25640a00 6164736b  bbb.....%d..adsk
 80000cd8 75666862 6573720a 00000000 67657420  ufhbesr.....get 
 80000ce8 25252064 20686572 650a0000 6572726f  %% d here...erro
 80000cf8 723a2075 6e6b6e6f 776e2066 6f726d61  r: unknown forma
 80000d08 740a0000 67657420 25252068 6572650a  t...get %% here.
 80000d18 00000000 73746f70 20686572 650a0000  ....stop here...
 80000d28 84060080 d4060080 100a0080 100a0080  ................
```

`80000d28` 就是计算出来的地址，初始的计算出来的跳转地址是 `8000 0648`是正确的，但是在执行的时候，不知道跳转到了哪里。

## 解决方案

目前采用：将 `switch` 的分支数目减少到5个以内，或者采用 `if-else` 语句代替 `switch` 语句实现。

在git的新的版本中，采用了 `if-else` 语句代替 `switch` 语句实现，问题得到解决。

相关细节：

> `make code` 指令后，观测 `result.txt` 和 `result1.txt` 文件，可以看到分支数量影响 `switch` 的实现方式。
> 观测 `result.txt`，发现 `jirl` 语句的跳转位置实际上在初始化的时候，填入了正确的分支对于的地址，但是在执行的时候，跳转到了错误的位置。说明：该地址对于的值被刷新了。
> 但是，此数据位于 `rodata` 段，不应该被刷新。无法解释，可能这就是硬件体系结构的困难和遗憾吧！


## 附注

由于到目前为止还没有 `gdb` 工具,所以在printf的实现中大量位置使用 `uart_puts` 函数进行调试输出。